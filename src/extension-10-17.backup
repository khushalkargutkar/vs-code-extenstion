
import * as vscode from 'vscode';
import * as fs from 'fs/promises';
import * as path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';
import * as os from 'os';
import * as https from 'https';
import { createWriteStream } from 'fs';

const execAsync = promisify(exec);

/**
 * Documentation URL for troubleshooting and additional information
 */
const DOCS_URL = 'https://docs.your-organization.com/commitguard';

/**
 * Interface for setup result tracking
 */
interface SetupResult {
  workspace: string;
  success: boolean;
  message: string;
  skipped?: boolean;
}

/**
 * Interface for prerequisite installation result
 */
interface PrerequisiteResult {
  installed: boolean;
  method: 'existing' | 'pip' | 'pip3' | 'python' | 'manual';
  message: string;
}

/**
 * Activates the CommitGuard extension
 * Sets up pre-commit hooks across all workspace folders on startup
 *
 * @param context - VS Code extension context
 */
export async function activate(context: vscode.ExtensionContext): Promise<void> {
  console.log('CommitGuard extension is now active');

  // Register the manual setup command
  const setupCommand = vscode.commands.registerCommand(
    'commitGuard.setupPreCommit',
    async () => {
      await setupPreCommitForAllWorkspaces(true);
    }
  );
  context.subscriptions.push(setupCommand);

  // Check if auto-setup is enabled
  const config = vscode.workspace.getConfiguration('commitGuard');
  const autoSetup = config.get<boolean>('autoSetupOnStartup', true);

  if (autoSetup) {
    console.log('CommitGuard: Running auto-setup on startup');
    await setupPreCommitForAllWorkspaces(false);
  } else {
    console.log('CommitGuard: Auto-setup is disabled in settings');
  }
}

/**
 * Deactivates the extension
 */
export function deactivate(): void {
  console.log('CommitGuard extension has been deactivated');
}

/**
 * Orchestrates pre-commit setup across all workspace folders
 *
 * @param manualTrigger - Whether this was manually triggered by user
 */
async function setupPreCommitForAllWorkspaces(manualTrigger: boolean): Promise<void> {
  // Check if we have any workspace folders
  const workspaceFolders = vscode.workspace.workspaceFolders;
  console.log(`CommitGuard: Found ${workspaceFolders?.length ?? 0} workspace folder(s)`);

  if (!workspaceFolders || workspaceFolders.length === 0) {
    vscode.window.showWarningMessage(
      'CommitGuard: No workspace folders found. Open a folder to setup pre-commit hooks.'
    );
    return;
  }

  // Step 1: Ensure pre-commit is available (best-effort, uses a temporary venv)
  console.log('CommitGuard: Checking for pre-commit installation...');
  const prereqResult = await vscode.window.withProgress(
    {
      location: vscode.ProgressLocation.Notification,
      title: 'CommitGuard',
      cancellable: false,
    },
    async (progress) => {
      progress.report({ message: 'Checking for pre-commit...' });
      return await ensurePreCommitInstalled(progress);
    }
  );

  if (!prereqResult.installed) {
    // Provide enterprise-friendly guidance
    const contactITAction = 'Contact IT';
    const tryManualAction = 'Try Manual Install';
    const viewDocsAction = 'View Documentation';

    const message = `CommitGuard: ${prereqResult.message}`;
    const actions = [tryManualAction, contactITAction, viewDocsAction];
    const result = await vscode.window.showErrorMessage(message, ...actions);

    if (result === tryManualAction) {
      // Open integrated terminal with manual install command
      const terminal = vscode.window.createTerminal('CommitGuard Setup');
      terminal.show();
      terminal.sendText('python -m pip install --user pre-commit');
      vscode.window.showInformationMessage(
        'CommitGuard: Manual installation command sent to terminal. After installation completes, restart VS Code and try again.'
      );
    } else if (result === contactITAction) {
      vscode.window.showInformationMessage(
        'CommitGuard: Please request your IT department to install Python 3.7+ and pre-commit on developer machines. ' +
          'Command for IT: python -m pip install pre-commit'
      );
    } else if (result === viewDocsAction) {
      vscode.env.openExternal(vscode.Uri.parse(DOCS_URL));
    }
    return;
  }

  if (prereqResult.method !== 'existing') {
    vscode.window.showInformationMessage(`CommitGuard: ${prereqResult.message}`);
  }
  console.log('CommitGuard: pre-commit is available');

  // Step 2: Setup pre-commit for each workspace folder
  const results: SetupResult[] = [];
  for (const folder of workspaceFolders) {
    const result = await setupPreCommitForWorkspace(folder);
    results.push(result);
  }

  // Step 3: Show summary to user
  displaySetupSummary(results, manualTrigger);
}

/**
 * Ensures pre-commit is installed, attempting automatic installation if needed
 * Tries multiple methods with focus on user-space installation for Windows
 *
 * @param progress - VS Code progress reporter for user feedback
 * @returns Installation result with method used
 */
async function ensurePreCommitInstalled(
  progress: vscode.Progress<{ message?: string; increment?: number }>
): Promise<PrerequisiteResult> {
  // First check if Python is available since we'll need it for venv
  console.log('CommitGuard: Checking for Python...');
  progress.report({ message: 'Checking prerequisites...' });
  const pythonInfo = await getPythonInfo();

  if (!pythonInfo.available) {
    console.error('CommitGuard: Python not found on system');
    return {
      installed: false,
      method: 'manual',
      message:
        'Python is not installed. Please contact your IT department to install Python 3.7+ or request pre-commit to be pre-installed on developer machines.',
    };
  }

  // Create a temporary workspace for installing pre-commit (best-effort)
  const tmpDir = path.join(os.tmpdir(), 'commitguard-setup');
  try {
    await fs.mkdir(tmpDir, { recursive: true });

    // Setup virtual environment in temp directory (installs pre-commit inside)
    progress.report({ message: 'Setting up virtual environment...' });
    const venvSetup = await setupVirtualEnvironment(tmpDir); // installs pre-commit inside
    if (venvSetup.success) {
      progress.report({ message: 'Pre-commit installed in virtual environment' });
      return {
        installed: true,
        method: 'python',
        message: 'Successfully installed pre-commit in virtual environment',
      };
    }
  } catch (error) {
    console.error('CommitGuard: Virtual environment setup failed:', error);
  }

  // If virtual environment approach failed, fall back to user-space installation (no admin required)
  progress.report({ message: 'Trying alternative installation methods...' });

  try {
    const installCmd = `${pythonInfo.command} -m pip install --user pre-commit`;
    console.log(`CommitGuard: Attempting user-space installation: ${installCmd}`);
    progress.report({ message: 'Installing pre-commit (this may take 30-60 seconds)...' });
    const result = await execAsync(installCmd, { timeout: 90_000 });
    console.log(`CommitGuard: Installation stdout: ${result.stdout}`);
    console.log(`CommitGuard: Installation stderr: ${result.stderr}`);

    // Verify installation succeeded
    progress.report({ message: 'Verifying installation...' });
    if (await checkPreCommitInstallation()) {
      console.log('CommitGuard: Successfully installed in user directory');
      return {
        installed: true,
        method: 'pip',
        message: 'Successfully installed pre-commit in user directory',
      };
    }

    // If not in PATH, check user Scripts/bin directory
    const userBinPath = await findPreCommitInUserSpace();
    if (userBinPath) {
      console.log(`CommitGuard: Found pre-commit at: ${userBinPath}`);
      return {
        installed: true,
        method: 'pip',
        message:
          'Successfully installed pre-commit in user directory. Note: You may need to restart VS Code for PATH changes to take effect.',
      };
    }
  } catch (error) {
    const errorDetails = error instanceof Error ? error.message : String(error);
    console.error('CommitGuard: User-space installation failed with error:', errorDetails);
    if (error && typeof error === 'object' && 'stderr' in error) {
      console.error('CommitGuard: stderr:', (error as any).stderr);
    }
    if (error && typeof error === 'object' && 'stdout' in error) {
      console.log('CommitGuard: stdout:', (error as any).stdout);
    }
  }

  // Installation failed
  console.error('CommitGuard: All installation attempts failed');
  return {
    installed: false,
    method: 'manual',
    message:
      'Could not automatically install pre-commit. Please ask your IT department to install it, or run: python -m pip install --user pre-commit',
  };
}

/**
 * Gets information about available Python installation
 *
 * @returns Python availability and command to use
 */
async function getPythonInfo(): Promise<{ available: boolean; command: string }> {
  const pythonCommands = ['python', 'python3', 'py'];
  for (const cmd of pythonCommands) {
    try {
      const result = await execAsync(`${cmd} --version`);
      console.log(`CommitGuard: Found Python via '${cmd}': ${result.stdout.trim()}`);
      return { available: true, command: cmd };
    } catch {
      // Continue checking other commands
    }
  }
  return { available: false, command: '' };
}

/**
 * Searches for pre-commit binary in user-space directories
 * On Windows: %APPDATA%\Python\PythonXX\Scripts
 * On Unix: ~/.local/bin
 *
 * @returns Path to pre-commit if found, null otherwise
 */
async function findPreCommitInUserSpace(): Promise<string | null> {
  try {
    const homeDir = process.env.HOME || process.env.USERPROFILE || '';
    if (process.platform === 'win32') {
      // Windows: Check AppData\Roaming\Python\PythonXX\Scripts
      const appData = process.env.APPDATA;
      if (appData) {
        const pythonDir = path.join(appData, 'Python');
        if (await checkPathExists(pythonDir)) {
          const dirs = await fs.readdir(pythonDir);
          for (const dir of dirs) {
            const scriptsDir = path.join(pythonDir, dir, 'Scripts');
            const preCommitPath = path.join(scriptsDir, 'pre-commit.exe');
            if (await checkPathExists(preCommitPath)) {
              console.log(`CommitGuard: Found pre-commit at: ${preCommitPath}`);
              return preCommitPath;
            }
          }
        }
      }
    } else {
      // Unix: Check ~/.local/bin
      const localBin = path.join(homeDir, '.local', 'bin', 'pre-commit');
      if (await checkPathExists(localBin)) {
        console.log(`CommitGuard: Found pre-commit at: ${localBin}`);
        return localBin;
      }
    }
  } catch (error) {
    console.error('CommitGuard: Error searching for pre-commit in user space:', error);
  }
  return null;
}

/**
 * Checks if the pre-commit binary is available on the system PATH
 * Uses cross-platform approach (which command on Unix, where on Windows)
 *
 * @returns true if pre-commit is available, false otherwise
 */
async function checkPreCommitInstallation(): Promise<boolean> {
  try {
    const command = process.platform === 'win32' ? 'where pre-commit' : 'which pre-commit';
    await execAsync(command);
    return true;
  } catch {
    return false;
  }
}

/**
 * Sets up pre-commit for a single workspace folder
 * Handles all validation, file creation, and hook installation
 *
 * @param workspaceFolder - The workspace folder to setup
 * @returns Setup result with status and message
 */
async function setupPreCommitForWorkspace(
  workspaceFolder: vscode.WorkspaceFolder
): Promise<SetupResult> {
  const workspacePath = workspaceFolder.uri.fsPath;
  const workspaceName = workspaceFolder.name;
  console.log(`CommitGuard: Processing workspace "${workspaceName}" at ${workspacePath}`);
  try {
    // Step 1: Check if this is a Git repository
    const gitPath = path.join(workspacePath, '.git');
    console.log(`CommitGuard: Checking for .git at ${gitPath}`);
    const hasGit = await checkPathExists(gitPath);
    if (!hasGit) {
      console.log(`CommitGuard: No .git found in ${workspaceName}`);
      return {
        workspace: workspaceName,
        success: true,
        message: 'Not a Git repository',
        skipped: true,
      };
    }
    console.log(`CommitGuard: .git found in ${workspaceName}`);

    // Step 2: Check if pre-commit config already exists
    const configPath = path.join(workspacePath, '.pre-commit-config.yaml');
    console.log(`CommitGuard: Checking for pre-commit config at ${configPath}`);
    const configExists = await checkPathExists(configPath);
    if (configExists) {
      console.log(`CommitGuard: Config already exists in ${workspaceName}`);
      // Still ensure the hook and venv exist for consistency
      const venvSetup = await setupVirtualEnvironment(workspacePath);
      if (!venvSetup.success) {
        throw new Error('Virtual environment setup failed');
      }
      await ensureVenvIgnored(workspacePath);
      await installPreCommitHooks(workspaceFolder, venvSetup.preCommitPath);

      return {
        workspace: workspaceName,
        success: true,
        message: 'Configuration already exists',
        skipped: true,
      };
    }

    console.log('CommitGuard: No existing config found, proceeding with setup');

    // Step 3: Prepare venv (+ pre-commit inside)
    const venvSetup = await setupVirtualEnvironment(workspacePath);
    if (!venvSetup.success) {
      throw new Error('Virtual environment setup failed');
    }

    // Step 3a: Ensure a Gitleaks binary is available within venv (no Go/Docker/PATH)
    const gitleaksPath = await ensureGitleaksAvailable(venvSetup.venvPath);

    // Step 3b: Ensure .venv is ignored
    await ensureVenvIgnored(workspacePath);

    // Step 3c: Generate configuration using a local hook that scans the entire working tree
    // const gitleaksEntryQuoted = `"${gitleaksPath}" detect --no-git --source . --redact --verbose`;
    // const content = buildDefaultPreCommitConfig(gitleaksEntryQuoted);
    
    const gitleaksEntry = `${gitleaksPath} detect --no-git --source . --redact --verbose`;
    const content = buildDefaultPreCommitConfigFromPath(gitleaksEntry);

    await generateConfigFile(configPath, content);

    // Step 4: Install pre-commit hooks (two-phase, robust)
    await installPreCommitHooks(workspaceFolder, venvSetup.preCommitPath);

    return {
      workspace: workspaceName,
      success: true,
      message: 'Successfully configured',
    };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error(`CommitGuard setup failed for ${workspaceName}:`, error);
    return {
      workspace: workspaceName,
      success: false,
      message: `Setup failed: ${errorMessage}`,
    };
  }
}

/**
 * Checks if a file or directory exists at the given path
 *
 * @param fsPath - The file system path to check
 * @returns true if path exists, false otherwise
 */
async function checkPathExists(fsPath: string): Promise<boolean> {
  try {
    await fs.access(fsPath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Builds the default .pre-commit-config.yaml content using a local Gitleaks entry.
 */
// function buildDefaultPreCommitConfig(gitleaksEntry: string): string {
//   return `# Generated by the CommitGuard extension

// function buildDefaultPreCommitConfig(gitleaksEntry: string): string {
//   // if you ever need to embed a single quote in the command, double it: ' --> ''
//   const entryYaml = `'${gitleaksEntry.replace(/'/g, "''")}'`;
//   return `# Generated by the CommitGuard extension

// repos:
//   - repo: https://github.com/pre-commit/pre-commit-hooks
//     rev: v4.5.0
//     hooks:
//       - id: trailing-whitespace
//       - id: end-of-file-fixer
//       - id: check-added-large-files

//   # Security: Gitleaks scanning of the full working tree (root & non-staged)
//   # Use a local/system hook to avoid Go/Docker requirements on corporate machines.
//   - repo: local
//     hooks:
//       - id: gitleaks-detect-full-tree
//         name: Detect hardcoded secrets with Gitleaks (full tree)
//         entry: ${entryYaml}
//         language: system
//         pass_filenames: false
// `;
// }

function buildDefaultPreCommitConfigFromPath(gitleaksPath: string): string {
  // Normalize to forward slashes for Windows safety
  const exe = gitleaksPath.replace(/\\/g, '/');

  return `# Generated by the CommitGuard extension
repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-added-large-files

  # Security: Gitleaks scanning of the full working tree (root & non-staged)
  # Use a local/system hook to avoid Go/Docker requirements on corporate machines.
  - repo: local
    hooks:
      - id: gitleaks-detect-full-tree
        name: Detect hardcoded secrets with Gitleaks (full tree)
        entry: ${exe}
        language: system
        pass_filenames: false
        args:
          - detect
          - --no-git
          - --source
          - .
          - --redact
          - --verbose
`;
}

/**
 * Generates the .pre-commit-config.yaml file
 * Uses custom configuration from settings if available, otherwise uses provided content
 *
 * @param configPath - Full path where config file should be created
 */
async function generateConfigFile(configPath: string, suppliedContent?: string): Promise<void> {
  try {
    // Get custom configuration from settings
    const config = vscode.workspace.getConfiguration('commitGuard');
    const customConfig = config.get<string>('precommitConfig', '');

    // Use custom config if provided, otherwise use supplied content
    const configContent = customConfig.trim() || (suppliedContent ?? '');

    // Write configuration file asynchronously
    await fs.writeFile(configPath, configContent, 'utf8');
    console.log(`CommitGuard: Created configuration file at ${configPath}`);
  } catch (error) {
    throw new Error(
      `Failed to create configuration file: ${
        error instanceof Error ? error.message : 'Unknown error'
      }`
    );
  }
}

/**
 * Sets up a virtual environment in the given folder
 * Installs pre-commit in the virtual environment
 *
 * @param workspacePath - The folder path (workspace or temp path)
 * @returns Object containing venv path, pip and pre-commit paths, and success status
 */
async function setupVirtualEnvironment(workspacePath: string): Promise<{
  venvPath: string;
  pipPath: string;
  preCommitPath: string;
  activateCmd: string;
  success: boolean;
}> {
  const venvPath = path.join(workspacePath, '.venv');
  console.log(`CommitGuard: Setting up virtual environment at ${venvPath}`);
  try {
    // Create virtual environment
    await execAsync(`python -m venv "${venvPath}"`, {
      cwd: workspacePath,
      timeout: 60_000,
    });
    console.log('CommitGuard: Virtual environment created successfully');

    // Get paths to executables and activation script
    const isWindows = process.platform === 'win32';
    const pipPath = isWindows
      ? path.join(venvPath, 'Scripts', 'pip.exe')
      : path.join(venvPath, 'bin', 'pip');
    const preCommitPath = isWindows
      ? path.join(venvPath, 'Scripts', 'pre-commit.exe')
      : path.join(venvPath, 'bin', 'pre-commit');
    const activateCmd = isWindows
      ? `"${path.join(venvPath, 'Scripts', 'activate.bat')}"`
      : `source ${path.join(venvPath, 'bin', 'activate')}`;

    // Install pre-commit in the virtual environment
    await execAsync(`"${pipPath}" install pre-commit`, {
      cwd: workspacePath,
      timeout: 120_000,
    });
    console.log('CommitGuard: pre-commit installed in virtual environment');

    return { venvPath, pipPath, preCommitPath, activateCmd, success: true };
  } catch (error) {
    console.error('CommitGuard: Virtual environment setup failed:', error);
    return { venvPath: '', pipPath: '', preCommitPath: '', activateCmd: '', success: false };
  }
}

/**
 * Installs pre-commit hooks with a two-phase strategy:
 *   1) Always install the hook script ("install -t pre-commit") and verify its presence.
 *   2) Best-effort warm up environments ("install-hooks -t pre-commit"); warn on failure but don't abort.
 *
 * @param workspaceFolder - The workspace folder where hooks should be installed
 * @param preCommitPathFromVenv - Optional absolute path to pre-commit in the venv to ensure isolation
 */
// async function installPreCommitHooks(
//   workspaceFolder: vscode.WorkspaceFolder,
//   preCommitPathFromVenv?: string
// ): Promise<void> {
//   try {
//     const config = vscode.workspace.getConfiguration('commitGuard');
//     const showTerminal = config.get<boolean>('showTerminalOnInstall', true);
//     const workspacePath = workspaceFolder.uri.fsPath;
//     const preCommitBin = preCommitPathFromVenv || 'pre-commit';

//     // PHASE 1: install hook script only (reliable, fast)
//     await execAsync(`"${preCommitBin}" install -t pre-commit`, {
//       cwd: workspacePath,
//       timeout: 120_000,
//       env: { ...process.env, PRE_COMMIT_HOME: path.join(workspacePath, '.pre-commit-cache') },
//     });

//     // verify hook file exists
//     const hookPath = path.join(workspacePath, '.git', 'hooks', 'pre-commit');
//     const hookExists = await checkPathExists(hookPath);
//     if (!hookExists) {
//       throw new Error('Hook script was not created at .git/hooks/pre-commit');
//     }
//     console.log(`CommitGuard: Verified hook file exists at ${hookPath}`);

//     // PHASE 2: best-effort warm up environments (may fail if a hook needs extra deps)
//     try {
//       await execAsync(`"${preCommitBin}" install-hooks -t pre-commit`, {
//         cwd: workspacePath,
//         timeout: 180_000,
//         env: { ...process.env, PRE_COMMIT_HOME: path.join(workspacePath, '.pre-commit-cache') },
//       });
//     } catch (e: any) {
//       const detail = e?.stderr || e?.stdout || e?.message || String(e);
//       console.warn('CommitGuard: install-hooks failed, continuing. Details:', detail);
//       vscode.window.showWarningMessage(
//         'CommitGuard: Hook installed. Installing hook environments failed; the first commit may build environments and could fail if prerequisites are missing.'
//       );
//     }

//     if (showTerminal) {
//       const terminal = vscode.window.createTerminal({
//         name: `CommitGuard: ${workspaceFolder.name}`,
//         cwd: workspacePath,
//       });
//       terminal.sendText(`echo "✅ CommitGuard: Pre-commit hooks successfully installed!"`);
//       terminal.sendText(`echo "Hooks are ready to run on your next commit."`);
//       terminal.show(true);
//     }

//     console.log(`CommitGuard: Successfully installed and verified hooks for ${workspaceFolder.name}`);
//   } catch (error) {
//     const errorMessage = error instanceof Error ? error.message : 'Unknown error';
//     console.error(`CommitGuard: Hook installation error:`, error);
//     throw new Error(`Failed to install pre-commit hooks: ${errorMessage}`);
//   }
// }

async function installPreCommitHooks(
  workspaceFolder: vscode.WorkspaceFolder,
  preCommitPathFromVenv?: string
): Promise<void> {
  try {
    const config = vscode.workspace.getConfiguration('commitGuard');
    const showTerminal = config.get<boolean>('showTerminalOnInstall', true);
    const workspacePath = workspaceFolder.uri.fsPath;
    const env = { ...process.env, PRE_COMMIT_HOME: path.join(workspacePath, '.pre-commit-cache') };

    // Use the venv’s pre-commit if provided; otherwise infer from .venv
    const preCommitBin =
      preCommitPathFromVenv ||
      path.join(
        workspacePath,
        '.venv',
        process.platform === 'win32' ? 'Scripts' : 'bin',
        process.platform === 'win32' ? 'pre-commit.exe' : 'pre-commit'
      );

    console.log('CommitGuard: PHASED INSTALL MODE (no --install-hooks up front)');

    // PHASE 1 — install only the hook script (fast, reliable)
    await execAsync(`"${preCommitBin}" install -t pre-commit`, {
      cwd: workspacePath,
      timeout: 120_000,
      env
    });

    // Verify hook file exists
    const hookPath = path.join(workspacePath, '.git', 'hooks', 'pre-commit');
    if (!(await checkPathExists(hookPath))) {
      throw new Error('Hook script was not created at .git/hooks/pre-commit');
    }
    console.log(`CommitGuard: Verified hook file exists at ${hookPath}`);

    // PHASE 2 — best-effort warm-up of hook environments
    try {
      await execAsync(`"${preCommitBin}" install-hooks`, {
        cwd: workspacePath,
        timeout: 180_000,
        env
      });
    } catch (e: any) {
      const detail = e?.stderr || e?.stdout || e?.message || String(e);
      console.warn('CommitGuard: install-hooks failed, continuing. Details:', detail);
      vscode.window.showWarningMessage(
        'CommitGuard: Hook installed. Installing hook environments failed; the first commit may build environments and could fail if prerequisites are missing.'
      );
    }

    if (showTerminal) {
      const terminal = vscode.window.createTerminal({
        name: `CommitGuard: ${workspaceFolder.name}`,
        cwd: workspacePath
      });
      terminal.sendText(`echo "✅ CommitGuard: Pre-commit hooks successfully installed!"`);
      terminal.sendText(`echo "Hooks are ready to run on your next commit."`);
      terminal.show(true);
    }

    console.log(`CommitGuard: Successfully installed and verified hooks for ${workspaceFolder.name}`);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error('CommitGuard: Hook installation error:', error);
    throw new Error(`Failed to install pre-commit hooks: ${errorMessage}`);
  }
}

/**
 * Ensure `.venv` is added to .gitignore (idempotent).
 */
async function ensureVenvIgnored(workspacePath: string): Promise<void> {
  try {
    const gitignorePath = path.join(workspacePath, '.gitignore');
    let content = '';
    try {
      content = await fs.readFile(gitignorePath, 'utf8');
    } catch {
      // file not present; we'll create it
    }
    const hasVenv = content.split(/\r?\n/).some((line) => line.trim() === '.venv');
    if (!hasVenv) {
      const next = (content.trim() ? content.trim() + '\n' : '') + '.venv\n';
      await fs.writeFile(gitignorePath, next, 'utf8');
      console.log(`CommitGuard: Added .venv to .gitignore at ${gitignorePath}`);
    } else {
      console.log('CommitGuard: .venv already present in .gitignore');
    }
  } catch (err) {
    console.warn('CommitGuard: Failed to update .gitignore:', err);
  }
}

/**
 * Downloads and installs a Gitleaks binary into the venv's bin/Scripts folder.
 * Returns the absolute path to the binary.
 *
 * We pin a stable Gitleaks version to keep behavior deterministic.
 */
async function ensureGitleaksAvailable(venvPath: string): Promise<string> {
  const isWindows = process.platform === 'win32';
  const binDir = isWindows ? path.join(venvPath, 'Scripts') : path.join(venvPath, 'bin');
  const target = path.join(binDir, isWindows ? 'gitleaks.exe' : 'gitleaks');

  if (await checkPathExists(target)) {
    return target;
  }

  // Choose asset by platform/arch
  const version = 'v8.28.0'; // update periodically to keep rules fresh
  const base = `https://github.com/gitleaks/gitleaks/releases/download/${version}`;
  const arch = process.arch;

  let asset = '';
  if (isWindows) {
    asset = 'gitleaks_8.28.0_windows_x64.zip'; // assuming x64 corporate images
  } else if (process.platform === 'darwin') {
    asset = arch === 'arm64'
      ? 'gitleaks_8.28.0_darwin_arm64.tar.gz'
      : 'gitleaks_8.28.0_darwin_x64.tar.gz';
  } else {
    // linux
    asset = arch === 'arm64'
      ? 'gitleaks_8.28.0_linux_arm64.tar.gz'
      : 'gitleaks_8.28.0_linux_x64.tar.gz';
  }
  const url = `${base}/${asset}`;

  // Download to temp
  const tmpDir = path.join(os.tmpdir(), 'commitguard-gitleaks');
  await fs.mkdir(tmpDir, { recursive: true });
  const archivePath = path.join(tmpDir, asset);
  await downloadFile(url, archivePath);

  // Extract using platform tools to avoid external libs
  if (isWindows) {
    // Use PowerShell Expand-Archive
    await execAsync(
      `powershell -NoProfile -Command "Expand-Archive -Path '${archivePath}' -DestinationPath '${tmpDir}' -Force"`,
      { timeout: 120_000 }
    );
    // The zip contains gitleaks.exe at the root in recent releases
    const exePath = path.join(tmpDir, 'gitleaks.exe');
    const nestedExe = (await checkPathExists(exePath))
      ? exePath
      : path.join(tmpDir, 'gitleaks', 'gitleaks.exe');

    await fs.mkdir(binDir, { recursive: true });
    await fs.copyFile(nestedExe, target);
  } else {
    await execAsync(`tar -xzf "${archivePath}" -C "${tmpDir}"`, { timeout: 120_000 });
    const binCandidate = path.join(tmpDir, 'gitleaks');
    const nested = (await checkPathExists(binCandidate))
      ? binCandidate
      : path.join(tmpDir, 'gitleaks', 'gitleaks');

    await fs.mkdir(binDir, { recursive: true });
    await fs.copyFile(nested, target);
    await fs.chmod(target, 0o755);
  }

  console.log(`CommitGuard: Installed Gitleaks binary at ${target}`);
  return target;
}

async function downloadFile(url: string, dest: string): Promise<void> {
  await new Promise<void>((resolve, reject) => {
    const file = createWriteStream(dest);
    https
      .get(url, (res) => {
        if (res.statusCode && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
          // redirect
          file.close();
          downloadFile(res.headers.location, dest).then(resolve).catch(reject);
          return;
        }
        if (res.statusCode !== 200) {
          file.close();
          reject(new Error(`HTTP ${res.statusCode} when downloading ${url}`));
          return;
        }
        res.pipe(file);
        file.on('finish', () => file.close(() => resolve()));
      })
      .on('error', (err) => {
        try {
          file.close();
        } catch {}
        reject(err);
      });
  });
}

/**
 * Displays a summary of setup results to the user
 * Shows different messages based on success/failure/skip status
 *
 * @param results - Array of setup results for all workspaces
 * @param manualTrigger - Whether setup was manually triggered
 */
function displaySetupSummary(results: SetupResult[], manualTrigger: boolean): void {
  const successful = results.filter((r) => r.success && !r.skipped);
  const failed = results.filter((r) => !r.success);
  const skipped = results.filter((r) => r.skipped);

  // If everything was skipped and it's not manual, don't show any message
  if (skipped.length === results.length && !manualTrigger) {
    return;
  }

  // Build summary message
  const messages: string[] = [];
  if (successful.length > 0) {
    messages.push(
      `✅ Configured ${successful.length} workspace(s): ${successful.map((r) => r.workspace).join(', ')}`
    );
  }
  if (skipped.length > 0) {
    messages.push(
      `⏭️ Skipped ${skipped.length} workspace(s): ${skipped
        .map((r) => `${r.workspace} (${r.message})`)
        .join(', ')}`
    );
  }
  if (failed.length > 0) {
    messages.push(
      `❌ Failed ${failed.length} workspace(s): ${failed
        .map((r) => `${r.workspace} - ${r.message}`)
        .join(', ')}`
    );
  }

  // Show appropriate message based on results
  if (failed.length > 0) {
    const viewDocsAction = 'View Documentation';
    vscode.window
      .showErrorMessage(`CommitGuard Setup Issues:\n${messages.join('\n')}`, viewDocsAction)
      .then((action) => {
        if (action === viewDocsAction) {
          vscode.env.openExternal(vscode.Uri.parse(DOCS_URL));
        }
      });
  } else if (successful.length > 0) {
    vscode.window.showInformationMessage(`CommitGuard: ${messages.join(' ')}`);
  } else if (manualTrigger) {
    // Only show "nothing to do" message if manually triggered
    vscode.window.showInformationMessage(`CommitGuard: ${messages.join(' ')}`);
  }
}
