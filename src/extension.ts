import * as vscode from 'vscode';
import * as fs from 'fs/promises';
import * as path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

/**
 * Documentation URL for troubleshooting and additional information
 */
const DOCS_URL = 'https://docs.your-organization.com/commitguard';

/**
 * Default enterprise-grade pre-commit configuration
 * This configuration includes:
 * - Basic code quality checks (whitespace, EOF, file size)
 * - Security scanning with Gitleaks for secret detection
 */
const DEFAULT_PRE_COMMIT_CONFIG = `# This file was automatically generated by the CommitGuard extension.
# It enforces enterprise-standard code quality and security checks.
repos:
  # Universal Basic Hooks (Trailing whitespace, End of File, Large files)
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-added-large-files

  # Security Hook: High-confidence secret detection for any staged file
  - repo: https://github.com/gitleaks/gitleaks
    rev: v8.18.4
    hooks:
      - id: gitleaks
        # Use 'protect' mode which scans staged changes
        # --redact hides actual secret values in output
        # --verbose shows which files are being scanned
        entry: gitleaks detect --no-git --source . --redact --verbose
`;

/**
 * Interface for setup result tracking
 */
interface SetupResult {
  workspace: string;
  success: boolean;
  message: string;
  skipped?: boolean;
}

/**
 * Interface for prerequisite installation result
 */
interface PrerequisiteResult {
  installed: boolean;
  method: 'existing' | 'pip' | 'pip3' | 'python' | 'manual';
  message: string;
}

/**
 * Activates the CommitGuard extension
 * Sets up pre-commit hooks across all workspace folders on startup
 * 
 * @param context - VS Code extension context
 */
export async function activate(context: vscode.ExtensionContext): Promise<void> {
  console.log('CommitGuard extension is now active');

  // Register the manual setup command
  const setupCommand = vscode.commands.registerCommand(
    'commitGuard.setupPreCommit',
    async () => {
      await setupPreCommitForAllWorkspaces(true);
    }
  );

  context.subscriptions.push(setupCommand);

  // Check if auto-setup is enabled
  const config = vscode.workspace.getConfiguration('commitGuard');
  const autoSetup = config.get<boolean>('autoSetupOnStartup', true);

  if (autoSetup) {
    // Run setup on activation (startup finished)
    console.log('CommitGuard: Running auto-setup on startup');
    await setupPreCommitForAllWorkspaces(false);
  } else {
    console.log('CommitGuard: Auto-setup is disabled in settings');
  }
}

/**
 * Deactivates the extension
 */
export function deactivate(): void {
  console.log('CommitGuard extension has been deactivated');
}

/**
 * Orchestrates pre-commit setup across all workspace folders
 * 
 * @param manualTrigger - Whether this was manually triggered by user
 */
async function setupPreCommitForAllWorkspaces(manualTrigger: boolean): Promise<void> {
  // Check if we have any workspace folders
  const workspaceFolders = vscode.workspace.workspaceFolders;
  
  console.log(`CommitGuard: Found ${workspaceFolders?.length || 0} workspace folder(s)`);
  
  if (!workspaceFolders || workspaceFolders.length === 0) {
    vscode.window.showWarningMessage(
      'CommitGuard: No workspace folders found. Open a folder to setup pre-commit hooks.'
    );
    return;
  }

  // Step 1: Ensure pre-commit is installed (with automatic installation)
  console.log('CommitGuard: Checking for pre-commit installation...');
  
  // Use progress notification for better UX
  const prereqResult = await vscode.window.withProgress({
    location: vscode.ProgressLocation.Notification,
    title: "CommitGuard",
    cancellable: false
  }, async (progress) => {
    progress.report({ message: "Checking for pre-commit..." });
    return await ensurePreCommitInstalled(progress);
  });
  
  if (!prereqResult.installed) {
    // Provide enterprise-friendly guidance
    const contactITAction = 'Contact IT';
    const tryManualAction = 'Try Manual Install';
    const viewDocsAction = 'View Documentation';
    
    const message = `CommitGuard: ${prereqResult.message}`;
    const actions = [tryManualAction, contactITAction, viewDocsAction];
    
    const result = await vscode.window.showErrorMessage(message, ...actions);
    
    if (result === tryManualAction) {
      // Open integrated terminal with manual install command
      const terminal = vscode.window.createTerminal('CommitGuard Setup');
      terminal.show();
      terminal.sendText('python -m pip install --user pre-commit');
      vscode.window.showInformationMessage(
        'CommitGuard: Manual installation command sent to terminal. After installation completes, restart VS Code and try again.'
      );
    } else if (result === contactITAction) {
      // Show IT contact information
      vscode.window.showInformationMessage(
        'CommitGuard: Please request your IT department to install Python 3.7+ and pre-commit on developer machines. ' +
        'Command for IT: python -m pip install pre-commit'
      );
    } else if (result === viewDocsAction) {
      vscode.env.openExternal(vscode.Uri.parse(DOCS_URL));
    }
    return;
  }

  if (prereqResult.method !== 'existing') {
    vscode.window.showInformationMessage(
      `CommitGuard: ${prereqResult.message}`
    );
  }

  console.log('CommitGuard: pre-commit is available');

  // Step 2: Setup pre-commit for each workspace folder
  const results: SetupResult[] = [];
  
  for (const folder of workspaceFolders) {
    const result = await setupPreCommitForWorkspace(folder);
    results.push(result);
  }

  // Step 3: Show summary to user
  displaySetupSummary(results, manualTrigger);
}

/**
 * Ensures pre-commit is installed, attempting automatic installation if needed
 * Tries multiple methods with focus on user-space installation for Windows
 * 
 * @param progress - VS Code progress reporter for user feedback
 * @returns Installation result with method used
 */
async function ensurePreCommitInstalled(
  progress: vscode.Progress<{ message?: string; increment?: number }>
): Promise<PrerequisiteResult> {
  // First, check if pre-commit is already available
  if (await checkPreCommitInstallation()) {
    console.log('CommitGuard: pre-commit already installed');
    return {
      installed: true,
      method: 'existing',
      message: 'pre-commit is already installed'
    };
  }

  console.log('CommitGuard: pre-commit not found, checking for Python...');
  progress.report({ message: "Checking prerequisites..." });

  // Check if Python is installed
  const pythonInfo = await getPythonInfo();
  
  if (!pythonInfo.available) {
    console.error('CommitGuard: Python not found on system');
    return {
      installed: false,
      method: 'manual',
      message: 'Python is not installed. Please contact your IT department to install Python 3.7+ or request pre-commit to be pre-installed on developer machines.'
    };
  }

  console.log(`CommitGuard: Python found at: ${pythonInfo.command}`);
  progress.report({ message: "Installing pre-commit in user directory..." });

  // Try user-space installation (no admin required)
  try {
    // Use --user flag to install in user directory (no admin needed)
    const installCmd = `${pythonInfo.command} -m pip install --user pre-commit`;
    console.log(`CommitGuard: Attempting user-space installation: ${installCmd}`);
    
    progress.report({ message: "Installing pre-commit (this may take 30-60 seconds)..." });
    
    const result = await execAsync(installCmd, { timeout: 90000 });
    console.log(`CommitGuard: Installation stdout: ${result.stdout}`);
    console.log(`CommitGuard: Installation stderr: ${result.stderr}`);
    
    // Verify installation succeeded
    progress.report({ message: "Verifying installation..." });
    
    // After user install, the binary might be in user's local bin directory
    // We need to check both PATH and common user bin locations
    if (await checkPreCommitInstallation()) {
      console.log('CommitGuard: Successfully installed in user directory');
      return {
        installed: true,
        method: 'pip',
        message: 'Successfully installed pre-commit in user directory'
      };
    }
    
    // If not in PATH, check user Scripts/bin directory
    const userBinPath = await findPreCommitInUserSpace();
    if (userBinPath) {
      console.log(`CommitGuard: Found pre-commit at: ${userBinPath}`);
      return {
        installed: true,
        method: 'pip',
        message: 'Successfully installed pre-commit in user directory. Note: You may need to restart VS Code for PATH changes to take effect.'
      };
    }
    
  } catch (error) {
    const errorDetails = error instanceof Error ? error.message : String(error);
    console.error('CommitGuard: User-space installation failed with error:', errorDetails);
    
    // Log stderr/stdout if available
    if (error && typeof error === 'object' && 'stderr' in error) {
      console.error('CommitGuard: stderr:', (error as any).stderr);
    }
    if (error && typeof error === 'object' && 'stdout' in error) {
      console.log('CommitGuard: stdout:', (error as any).stdout);
    }
  }

  // Installation failed
  console.error('CommitGuard: All installation attempts failed');
  return {
    installed: false,
    method: 'manual',
    message: 'Could not automatically install pre-commit. Please ask your IT department to install it, or run: python -m pip install --user pre-commit'
  };
}

/**
 * Gets information about available Python installation
 * 
 * @returns Python availability and command to use
 */
async function getPythonInfo(): Promise<{ available: boolean; command: string }> {
  const pythonCommands = ['python', 'python3', 'py'];
  
  for (const cmd of pythonCommands) {
    try {
      const result = await execAsync(`${cmd} --version`);
      console.log(`CommitGuard: Found Python via '${cmd}': ${result.stdout.trim()}`);
      return { available: true, command: cmd };
    } catch (error) {
      // Continue checking other commands
    }
  }
  
  return { available: false, command: '' };
}

/**
 * Searches for pre-commit binary in user-space directories
 * On Windows: %APPDATA%\Python\PythonXX\Scripts
 * On Unix: ~/.local/bin
 * 
 * @returns Path to pre-commit if found, null otherwise
 */
async function findPreCommitInUserSpace(): Promise<string | null> {
  try {
    const homeDir = process.env.HOME || process.env.USERPROFILE || '';
    
    if (process.platform === 'win32') {
      // Windows: Check AppData\Roaming\Python\PythonXX\Scripts
      const appData = process.env.APPDATA;
      if (appData) {
        const pythonDir = path.join(appData, 'Python');
        
        // Check if Python directory exists
        if (await checkPathExists(pythonDir)) {
          // Look for Python version directories (Python37, Python38, etc.)
          const dirs = await fs.readdir(pythonDir);
          for (const dir of dirs) {
            const scriptsDir = path.join(pythonDir, dir, 'Scripts');
            const preCommitPath = path.join(scriptsDir, 'pre-commit.exe');
            
            if (await checkPathExists(preCommitPath)) {
              console.log(`CommitGuard: Found pre-commit at: ${preCommitPath}`);
              return preCommitPath;
            }
          }
        }
      }
    } else {
      // Unix: Check ~/.local/bin
      const localBin = path.join(homeDir, '.local', 'bin', 'pre-commit');
      if (await checkPathExists(localBin)) {
        console.log(`CommitGuard: Found pre-commit at: ${localBin}`);
        return localBin;
      }
    }
  } catch (error) {
    console.error('CommitGuard: Error searching for pre-commit in user space:', error);
  }
  
  return null;
}

/**
 * Checks if the pre-commit binary is available on the system PATH
 * Uses cross-platform approach (which command on Unix, where on Windows)
 * 
 * @returns true if pre-commit is available, false otherwise
 */
async function checkPreCommitInstallation(): Promise<boolean> {
  try {
    const command = process.platform === 'win32' 
      ? 'where pre-commit' 
      : 'which pre-commit';
    
    await execAsync(command);
    return true;
  } catch (error) {
    // Command failed - pre-commit not found
    return false;
  }
}

/**
 * Sets up pre-commit hooks for a single workspace folder
 * Handles all validation, file creation, and hook installation
 * 
 * @param workspaceFolder - The workspace folder to setup
 * @returns Setup result with status and message
 */
async function setupPreCommitForWorkspace(
  workspaceFolder: vscode.WorkspaceFolder
): Promise<SetupResult> {
  const workspacePath = workspaceFolder.uri.fsPath;
  const workspaceName = workspaceFolder.name;

  console.log(`CommitGuard: Processing workspace "${workspaceName}" at ${workspacePath}`);

  try {
    // Step 1: Check if this is a Git repository
    const gitPath = path.join(workspacePath, '.git');
    console.log(`CommitGuard: Checking for .git at ${gitPath}`);
    const hasGit = await checkPathExists(gitPath);
    
    if (!hasGit) {
      console.log(`CommitGuard: No .git found in ${workspaceName}`);
      return {
        workspace: workspaceName,
        success: true,
        message: 'Not a Git repository',
        skipped: true
      };
    }
    
    console.log(`CommitGuard: .git found in ${workspaceName}`);

    // Step 2: Check if pre-commit config already exists
    const configPath = path.join(workspacePath, '.pre-commit-config.yaml');
    console.log(`CommitGuard: Checking for existing config at ${configPath}`);
    const configExists = await checkPathExists(configPath);
    
    if (configExists) {
      console.log(`CommitGuard: Config already exists in ${workspaceName}`);
      return {
        workspace: workspaceName,
        success: true,
        message: 'Configuration already exists',
        skipped: true
      };
    }
    
    console.log(`CommitGuard: No existing config found, proceeding with setup`);

    // Step 3: Generate configuration file
    await generateConfigFile(configPath);

    // Step 4: Install pre-commit hooks
    await installPreCommitHooks(workspaceFolder);

    return {
      workspace: workspaceName,
      success: true,
      message: 'Successfully configured'
    };

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error(`CommitGuard setup failed for ${workspaceName}:`, error);
    
    return {
      workspace: workspaceName,
      success: false,
      message: `Setup failed: ${errorMessage}`
    };
  }
}

/**
 * Checks if a file or directory exists at the given path
 * 
 * @param fsPath - The file system path to check
 * @returns true if path exists, false otherwise
 */
async function checkPathExists(fsPath: string): Promise<boolean> {
  try {
    await fs.access(fsPath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Generates the .pre-commit-config.yaml file
 * Uses custom configuration from settings if available, otherwise uses default
 * 
 * @param configPath - Full path where config file should be created
 */
async function generateConfigFile(configPath: string): Promise<void> {
  try {
    // Get custom configuration from settings
    const config = vscode.workspace.getConfiguration('commitGuard');
    const customConfig = config.get<string>('precommitConfig', '');
    
    // Use custom config if provided, otherwise use default
    const configContent = customConfig.trim() || DEFAULT_PRE_COMMIT_CONFIG;
    
    // Write configuration file asynchronously
    await fs.writeFile(configPath, configContent, 'utf8');
    
    console.log(`CommitGuard: Created configuration file at ${configPath}`);
  } catch (error) {
    throw new Error(
      `Failed to create configuration file: ${error instanceof Error ? error.message : 'Unknown error'}`
    );
  }
}

/**
 * Installs pre-commit hooks by running 'pre-commit install'
 * Uses Python module invocation to work even if pre-commit is not in PATH
 * 
 * @param workspaceFolder - The workspace folder where hooks should be installed
 */
async function installPreCommitHooks(
  workspaceFolder: vscode.WorkspaceFolder
): Promise<void> {
  try {
    const config = vscode.workspace.getConfiguration('commitGuard');
    const showTerminal = config.get<boolean>('showTerminalOnInstall', true);

    // Get the Python command to use
    const pythonInfo = await getPythonInfo();
    if (!pythonInfo.available) {
      throw new Error('Python not found - cannot install hooks');
    }

    console.log(`CommitGuard: Installing hooks using: ${pythonInfo.command} -m pre_commit install`);

    // Try to run pre-commit install directly first (if it's in PATH)
    let installSuccess = false;
    
    try {
      // Attempt 1: Try 'pre-commit install' if it's in PATH
      await execAsync('pre-commit install --install-hooks', { 
        cwd: workspaceFolder.uri.fsPath,
        timeout: 120000 // 2 minutes for hook environment setup
      });
      console.log('CommitGuard: Hooks installed via pre-commit CLI');
      installSuccess = true;
    } catch (error) {
      console.log('CommitGuard: pre-commit CLI not in PATH, trying Python module...');
      
      // Attempt 2: Use Python module invocation (works even if not in PATH)
      try {
        const result = await execAsync(`${pythonInfo.command} -m pre_commit install --install-hooks`, {
          cwd: workspaceFolder.uri.fsPath,
          timeout: 120000 // 2 minutes for hook environment setup
        });
        console.log('CommitGuard: Hooks installed via Python module');
        console.log(`CommitGuard: Install output: ${result.stdout}`);
        if (result.stderr) {
          console.log(`CommitGuard: Install stderr: ${result.stderr}`);
        }
        installSuccess = true;
      } catch (moduleError) {
        const errorMsg = moduleError instanceof Error ? moduleError.message : String(moduleError);
        console.error('CommitGuard: Python module installation also failed:', errorMsg);
        throw new Error(`Failed to install hooks: ${errorMsg}`);
      }
    }

    if (!installSuccess) {
      throw new Error('Hook installation did not complete successfully');
    }

    // Verify hooks were actually installed by checking for the pre-commit hook file
    const hookPath = path.join(workspaceFolder.uri.fsPath, '.git', 'hooks', 'pre-commit');
    const hookExists = await checkPathExists(hookPath);
    
    if (!hookExists) {
      throw new Error('Hook installation completed but .git/hooks/pre-commit file was not created');
    }

    console.log(`CommitGuard: Verified hook file exists at ${hookPath}`);

    // Show terminal with success message
    if (showTerminal) {
      const terminal = vscode.window.createTerminal({
        name: `CommitGuard: ${workspaceFolder.name}`,
        cwd: workspaceFolder.uri.fsPath,
      });
      
      // Show a success message in the terminal
      terminal.sendText(`echo "✅ CommitGuard: Pre-commit hooks successfully installed!"`);
      terminal.sendText(`echo "Hooks are ready to run on your next commit."`);
      terminal.show(true);
    }

    console.log(`CommitGuard: Successfully installed and verified hooks for ${workspaceFolder.name}`);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error(`CommitGuard: Hook installation error:`, error);
    throw new Error(`Failed to install pre-commit hooks: ${errorMessage}`);
  }
}

/**
 * Displays a summary of setup results to the user
 * Shows different messages based on success/failure/skip status
 * 
 * @param results - Array of setup results for all workspaces
 * @param manualTrigger - Whether setup was manually triggered
 */
function displaySetupSummary(results: SetupResult[], manualTrigger: boolean): void {
  const successful = results.filter(r => r.success && !r.skipped);
  const failed = results.filter(r => !r.success);
  const skipped = results.filter(r => r.skipped);

  // If everything was skipped and it's not manual, don't show any message
  if (skipped.length === results.length && !manualTrigger) {
    return;
  }

  // Build summary message
  const messages: string[] = [];
  
  if (successful.length > 0) {
    messages.push(`✅ Configured ${successful.length} workspace(s): ${successful.map(r => r.workspace).join(', ')}`);
  }
  
  if (skipped.length > 0) {
    messages.push(`⏭️  Skipped ${skipped.length} workspace(s): ${skipped.map(r => `${r.workspace} (${r.message})`).join(', ')}`);
  }
  
  if (failed.length > 0) {
    messages.push(`❌ Failed ${failed.length} workspace(s): ${failed.map(r => `${r.workspace} - ${r.message}`).join(', ')}`);
  }

  // Show appropriate message based on results
  if (failed.length > 0) {
    const viewDocsAction = 'View Documentation';
    vscode.window.showErrorMessage(
      `CommitGuard Setup Issues:\n${messages.join('\n')}`,
      viewDocsAction
    ).then(action => {
      if (action === viewDocsAction) {
        vscode.env.openExternal(vscode.Uri.parse(DOCS_URL));
      }
    });
  } else if (successful.length > 0) {
    vscode.window.showInformationMessage(
      `CommitGuard: ${messages.join(' ')}`
    );
  } else if (manualTrigger) {
    // Only show "nothing to do" message if manually triggered
    vscode.window.showInformationMessage(
      `CommitGuard: ${messages.join(' ')}`
    );
  }
}